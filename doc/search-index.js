var searchIndex = {};
searchIndex['portaudio'] = {"items":[[0,"","portaudio","# Rust-PortAudio"],[0,"types","","Types used in the PortAudio API"],[1,"PaHostApiInfo","portaudio::types","A structure containing information about a particular host API."],[11,"struct_version","","The version of the struct",0],[11,"host_type","","The type of the current host",0],[11,"name","","The name of the host",0],[11,"device_count","","The total count of device in the host",0],[11,"default_input_device","","The index to the default input device",0],[11,"default_output_device","","The index to the default output device",0],[1,"PaHostErrorInfo","","Structure used to return information about a host error condition."],[11,"error_code","","The code of the error",1],[11,"error_text","","The string which explain the error",1],[1,"PaDeviceInfo","","A structure providing information and capabilities of PortAudio devices.\nDevices may support input, output or both input and output."],[11,"struct_version","","The version of the struct",2],[11,"name","","The name of the devie",2],[11,"host_api","","Host API identifier",2],[11,"max_input_channels","","Maximal number of input channels for this device",2],[11,"max_output_channels","","maximal number of output channel for this device",2],[11,"default_low_input_latency","","The default low latency for input with this device",2],[11,"default_low_output_latency","","The default low latency for output with this device",2],[11,"default_high_input_latency","","The default high latency for input with this device",2],[11,"default_high_output_latency","","The default high latency for output with this device",2],[11,"default_sample_rate","","The default sample rate for this device",2],[1,"PaStreamParameters","","Parameters for one direction (input or output) of a stream."],[11,"device","","Index of the device",3],[11,"channel_count","","The number of channels for this device",3],[11,"sample_format","","Sample format of the device",3],[11,"suggested_latency","","The suggested latency for this device",3],[1,"PaStreamInfo","","A structure containing unchanging information about an open stream."],[11,"struct_version","","Struct version",4],[11,"input_latency","","The input latency for this open stream",4],[11,"output_latency","","The output latency for this open stream",4],[11,"sample_rate","","The sample rate for this open stream",4],[2,"PaSampleFormat","","A type used to specify one or more sample formats."],[12,"PaFloat32","","32 bits float sample format",5],[12,"PaInt32","","32 bits int sample format",5],[12,"PaInt16","","16 bits int sample format",5],[12,"PaInt8","","8 bits int sample format",5],[12,"PaUInt8","","8 bits unsigned int sample format",5],[12,"PaCustomFormat","","Custom sample format",5],[12,"PaNonInterleaved","","Non interleaved sample format",5],[2,"PaStreamFlags","","The flags to pass to a stream"],[12,"PaNoFlag","","No flags",6],[12,"PaClipOff","","Disable default clipping of out of range samples.",6],[12,"PaDitherOff","","Disable default dithering.",6],[12,"PaNeverDropInput","","Flag requests that where possible a full duplex stream will not discard overflowed input samples without calling the stream callback.",6],[12,"PaPrimeOutputBuffersUsingStreamCallback","","Call the stream callback to fill initial output buffers, rather than the default behavior of priming the buffers with zeros (silence)",6],[12,"PaPlatformSpecificFlags","","A mask specifying the platform specific bits.",6],[2,"PaError","","Error codes returned by PortAudio functions."],[12,"PaNoError","","No Error",7],[12,"PaNotInitialized","","Portaudio not initialized",7],[12,"PaUnanticipatedHostError","","Unanticipated error from the host",7],[12,"PaInvalidChannelCount","","Invalid channel count",7],[12,"PaInvalidSampleRate","","Invalid sample rate",7],[12,"PaInvalidDevice","","Invalid Device",7],[12,"PaInvalidFlag","","Invalid Flag",7],[12,"PaSampleFormatNotSupported","","The Sample format is not supported",7],[12,"PaBadIODeviceCombination","","Input device not compatible with output device",7],[12,"PaInsufficientMemory","","Memory insufficient",7],[12,"PaBufferTooBig","","The buffer is too big",7],[12,"PaBufferTooSmall","","The buffer is too small",7],[12,"PaNullCallback","","Invalid callback",7],[12,"PaBadStreamPtr","","Invalid Stream",7],[12,"PaTimedOut","","Time out",7],[12,"PaInternalError","","Portaudio internal error",7],[12,"PaDeviceUnavailable","","Device unavailable",7],[12,"PaIncompatibleHostApiSpecificStreamInfo","","Stream info not compatible with the host",7],[12,"PaStreamIsStopped","","The stream is stopped",7],[12,"PaStreamIsNotStopped","","The stream is not stopped",7],[12,"PaInputOverflowed","","The input stream has overflowed",7],[12,"PaOutputUnderflowed","","The output has overflowed",7],[12,"PaHostApiNotFound","","The host API is not found by Portaudio",7],[12,"PaInvalidHostApi","","The host API is invalid",7],[12,"PaCanNotReadFromACallbackStream","","Portaudio cannot read from the callback stream",7],[12,"PaCanNotWriteToACallbackStream","","Portaudio cannot wrtie to the callback stream",7],[12,"PaCanNotReadFromAnOutputOnlyStream","","Portaudio cannot read from an output only stream",7],[12,"PaCanNotWriteToAnInputOnlyStream","","Portaudio cannot write to an input only stream",7],[12,"PaIncompatibleStreamHostApi","","The stream is not compatible with the host API",7],[12,"PaBadBufferPtr","","Invalid buffer",7],[2,"PaHostApiTypeId","","Unchanging unique identifiers for each supported host API"],[12,"PaInDevelopment","","In development host",8],[12,"PaDirectSound","","Direct sound",8],[12,"PaMME","","MMe API",8],[12,"PaASIO","","ASIO API",8],[12,"PaSoundManager","","Sound manager API",8],[12,"PaCoreAudio","","Core Audio API",8],[12,"PaOSS","","OSS API",8],[12,"PaALSA","","Alsa API",8],[12,"PaAL","","AL API",8],[12,"PaBeOS","","BeOS API",8],[12,"PaWDMKS","","WDMKS",8],[12,"PaJACK","","Jack API",8],[12,"PaWASAPI","","WASAPI",8],[12,"PaAudioScienceHPI","","Audio Science HPI",8],[4,"PaDeviceIndex","","The type used to refer to audio devices. Values of this type usually range\nfrom 0 to (pa::get_device_count()-1)"],[4,"PaHostApiIndex","","The type used to enumerate to host APIs at runtime.\nValues of this type range from 0 to (pa::get_host_api_count()-1)."],[4,"PaTime","","The type used to represent monotonic time in seconds."],[18,"PA_NO_DEVICE","","A special PaDeviceIndex value indicating that no device is available,\nor should be used."],[18,"PA_USE_HOST_API_SPECIFIC_DEVICE_SPECIFICATION","","A special PaDeviceIndex value indicating that the device(s) to be used are\nspecified in the host api specific stream info structure."],[10,"fmt","","",5],[10,"partial_cmp","","",5],[10,"lt","","",5],[10,"le","","",5],[10,"gt","","",5],[10,"ge","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"clone","","",5],[10,"fmt","","",6],[10,"partial_cmp","","",6],[10,"lt","","",6],[10,"le","","",6],[10,"gt","","",6],[10,"ge","","",6],[10,"eq","","",6],[10,"ne","","",6],[10,"clone","","",6],[10,"fmt","","",7],[10,"partial_cmp","","",7],[10,"lt","","",7],[10,"le","","",7],[10,"gt","","",7],[10,"ge","","",7],[10,"eq","","",7],[10,"ne","","",7],[10,"clone","","",7],[10,"fmt","","",8],[10,"partial_cmp","","",8],[10,"lt","","",8],[10,"le","","",8],[10,"gt","","",8],[10,"ge","","",8],[10,"eq","","",8],[10,"ne","","",8],[10,"clone","","",8],[10,"fmt","","",1],[10,"partial_cmp","","",1],[10,"lt","","",1],[10,"le","","",1],[10,"gt","","",1],[10,"ge","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"clone","","",1],[10,"fmt","","",2],[10,"partial_cmp","","",2],[10,"lt","","",2],[10,"le","","",2],[10,"gt","","",2],[10,"ge","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"clone","","",2],[10,"fmt","","",3],[10,"partial_cmp","","",3],[10,"lt","","",3],[10,"le","","",3],[10,"gt","","",3],[10,"ge","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"clone","","",3],[10,"fmt","","",4],[10,"partial_cmp","","",4],[10,"lt","","",4],[10,"le","","",4],[10,"gt","","",4],[10,"ge","","",4],[10,"eq","","",4],[10,"ne","","",4],[10,"clone","","",4],[0,"pa","portaudio","The portable PortAudio API."],[1,"PaStream","portaudio::pa","Representation of an audio stream, where the format of the stream is defined\nby the S parameter."],[3,"get_version","","Retrieve the release number of the currently running PortAudio build."],[3,"get_version_text","","Retrieve a textual description of the current PortAudio build."],[3,"get_error_text","","Translate the supplied PortAudio error code into a human readable message."],[3,"initialize","","Library initialization function - call this before using PortAudio.\nThis function initializes internal data structures and prepares underlying\nhost APIs for use. With the exception of get_version(), get_version_text(),\nand get_error_text(), this function MUST be called before using any other\nPortAudio API functions."],[3,"terminate","","Library termination function - call this when finished using PortAudio.\nThis function deallocates all resources allocated by PortAudio since it was\ninitialized by a call to initialize(). In cases where initialise() has been\ncalled multiple times, each call must be matched with a corresponding call to\nterminate(). The final matching call to terminate() will automatically close\nany PortAudio streams that are still open."],[3,"get_last_host_error_info","","Return information about the last host error encountered.\nThe error information returned by get_last_host_error_info() will never be\nmodified asynchronously by errors occurring in other PortAudio owned threads\n(such as the thread that manages the stream callback.)"],[3,"is_format_supported","","Determine whether it would be possible to open a stream with the specified\nparameters."],[3,"get_sample_size","","Retrieve the size of a given sample format in bytes."],[3,"sleep","","Put the caller to sleep for at least 'msec' milliseconds.\nThis function is provided only as a convenience for authors of portable code\n(such as the tests and examples in the PortAudio distribution.)"],[0,"device","","Device management"],[3,"get_count","portaudio::pa::device","Retrieve the number of available devices. The number of available devices may\nbe zero."],[3,"get_default_input","","Retrieve the index of the default input device.\nThe result can be used in the inputDevice parameter to open_stream()."],[3,"get_default_output","","Retrieve the index of the default output device. The result can be\nused in the outputDevice parameter to open_stream()."],[3,"get_info","","Retrieve a pointer to a PaDeviceInfo structure containing information about\nthe specified device."],[0,"host","portaudio::pa","Host api management"],[3,"get_api_count","portaudio::pa::host","Retrieve the number of available host APIs.\nEven if a host API is available it may have no devices available."],[3,"get_default_api","","Retrieve the index of the default host API.\nThe default host API will be the lowest common denominator host API\non the current platform and is unlikely to provide the best performance."],[3,"get_api_info","","Retrieve a pointer to a structure containing information about a specific host\nApi."],[3,"api_type_id_to_host_api_index","","Convert a static host API unique identifier, into a runtime host API index."],[3,"api_device_index_to_device_index","","Convert a host-API-specific device index to standard PortAudio device index.\nThis function may be used in conjunction with the deviceCount field of\nPaHostApiInfo to enumerate all devices for the specified host API."],[10,"new","portaudio::pa","Constructor for PaStream.",9],[10,"open","","Opens a stream for either input, output or both.",9],[10,"open_default","","A simplified version of open() that opens the default input and/or output\ndevices.",9],[10,"close","","Closes an audio stream. If the audio stream is active it discards any\npending buffers as if abort_tream() had been called.",9],[10,"start","","Commences audio processing.",9],[10,"stop","","Terminates audio processing. It waits until all pending audio buffers\nhave been played before it returns.",9],[10,"abort","","Terminates audio processing immediately without waiting for pending\nbuffers to complete.",9],[10,"is_stopped","","Determine whether the stream is stopped.\nA stream is considered to be stopped prior to a successful call to\nstart_stream and after a successful call to stop_stream or abort_stream.\nIf a stream callback returns a value other than PaContinue the stream is\nNOT considered to be stopped.",9],[10,"is_active","","Determine whether the stream is active. A stream is active after a\nsuccessful call to start_stream(), until it becomes inactive either as a\nresult of a call to stop_stream() or abort_stream(), or as a result of a\nreturn value other than paContinue from the stream callback. In the latter\ncase, the stream is considered inactive after the last buffer has finished\nplaying.",9],[10,"get_stream_time","","Returns the current time in seconds for a stream according to the same\nclock used to generate callback PaStreamCallbackTimeInfo timestamps.\nThe time values are monotonically increasing and have unspecified origin.",9],[10,"get_stream_cpu_load","","Retrieve CPU usage information for the specified stream.",9],[10,"get_stream_read_available","","Retrieve the number of frames that can be read from the stream without\nwaiting.",9],[10,"get_stream_write_available","","Retrieve the number of frames that can be written to the stream without\nwaiting.",9],[10,"write","","Write samples to an output stream.\nThis function doesn't return until the entire buffer has been consumed\n- this may involve waiting for the operating system to consume the data.",9],[10,"get_stream_info","","Retrieve a PaStreamInfo structure containing information about the\nspecified stream.",9]],"paths":[[1,"PaHostApiInfo"],[1,"PaHostErrorInfo"],[1,"PaDeviceInfo"],[1,"PaStreamParameters"],[1,"PaStreamInfo"],[2,"PaSampleFormat"],[2,"PaStreamFlags"],[2,"PaError"],[2,"PaHostApiTypeId"],[1,"PaStream"]]};
initSearch(searchIndex);
